package com.ble1st.connectias.core.plugin

import android.content.Context
import kotlinx.coroutines.*
import timber.log.Timber
import java.io.File
import dalvik.system.DexClassLoader
import java.util.concurrent.ConcurrentHashMap
import java.util.jar.JarFile
import org.json.JSONObject
import org.json.JSONArray
import com.ble1st.connectias.plugin.IPlugin
import com.ble1st.connectias.plugin.PluginMetadata
import com.ble1st.connectias.plugin.PluginCategory

/**
 * Manages plugin lifecycle and discovery
 */
class PluginManager(
    private val context: Context,
    private val pluginDirectory: File
) {
    
    companion object {
        private const val PLUGIN_LOAD_TIMEOUT_MS = 10000L      // 10 seconds
        private const val PLUGIN_ENABLE_TIMEOUT_MS = 5000L     // 5 seconds
        private const val PLUGIN_DISABLE_TIMEOUT_MS = 5000L    // 5 seconds
        private const val PLUGIN_UNLOAD_TIMEOUT_MS = 5000L     // 5 seconds
    }
    
    private val loadedPlugins = ConcurrentHashMap<String, PluginInfo>()
    private val classLoaders = ConcurrentHashMap<String, DexClassLoader>()
    private val pluginContexts = ConcurrentHashMap<String, PluginContextImpl>()
    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    
    /**
     * Plugin information during runtime
     */
    data class PluginInfo(
        val pluginId: String,
        val metadata: PluginMetadata,
        val instance: IPlugin,
        val classLoader: DexClassLoader,
        val state: PluginState,
        val loadedAt: Long
    )
    
    enum class PluginState {
        LOADED,      // Loaded but not activated
        ENABLED,     // Activated and working
        DISABLED,    // Disabled but still in memory
        ERROR        // Error during loading
    }
    
    /**
     * Initializes plugin directory and loads available plugins
     */
    suspend fun initialize(): Result<List<PluginMetadata>> = withContext(Dispatchers.IO) {
        try {
            // Create plugin directory if it doesn't exist
            if (!pluginDirectory.exists()) {
                pluginDirectory.mkdirs()
            }
            
            // Scan for plugin AABs
            val pluginFiles = pluginDirectory.listFiles { file ->
                file.extension == "aab" || file.extension == "jar" || file.extension == "apk"
            } ?: emptyArray()
            
            Timber.d("Found ${pluginFiles.size} plugin files")
            
            // Load all plugins
            val loadedMetadata = mutableListOf<PluginMetadata>()
            for (pluginFile in pluginFiles) {
                val result = loadPlugin(pluginFile)
                if (result.isSuccess) {
                    val pluginInfo = result.getOrNull()
                    if (pluginInfo != null) {
                        loadedMetadata.add(pluginInfo.metadata)
                    }
                }
            }
            
            Result.success(loadedMetadata)
        } catch (e: Exception) {
            Timber.e(e, "Failed to initialize plugin manager")
            Result.failure(e)
        }
    }
    
    /**
     * Loads a plugin from an AAB/JAR file
     */
    suspend fun loadPlugin(pluginFile: File): Result<PluginInfo> = withContext(Dispatchers.IO) {
        try {
            // Timeout protection
            withTimeoutOrNull(PLUGIN_LOAD_TIMEOUT_MS) {
                loadPluginInternal(pluginFile)
            } ?: Result.failure(Exception("Plugin load timeout after ${PLUGIN_LOAD_TIMEOUT_MS}ms"))
        } catch (e: Exception) {
            Timber.e(e, "Failed to load plugin: ${pluginFile.name}")
            Result.failure(e)
        }
    }
    
    private suspend fun loadPluginInternal(pluginFile: File): Result<PluginInfo> {
        try {
            // 1. Extract plugin manifest
            val metadata = extractPluginMetadata(pluginFile)
            
            // 2. Validate plugin
            validatePlugin(metadata)
            
            // 3. Create DEX output directory
            val dexOutputDir = File(context.codeCacheDir, "plugins/${metadata.pluginId}")
            if (!dexOutputDir.exists()) {
                dexOutputDir.mkdirs()
            }
            
            // 4. Create DexClassLoader for APK/JAR
            val classLoader = DexClassLoader(
                pluginFile.absolutePath,
                dexOutputDir.absolutePath,
                null,
                context.classLoader
            )
            
            // 5. Instantiate plugin class
            val pluginClass = classLoader.loadClass(
                metadata.fragmentClassName ?: throw IllegalArgumentException("fragmentClassName is required")
            )
            val pluginInstance = pluginClass.getDeclaredConstructor().newInstance() as? IPlugin
                ?: throw ClassCastException("Plugin class does not implement IPlugin")
            
            // 6. Create PluginContext
            val pluginContext = PluginContextImpl(
                appContext = context,
                pluginDir = File(pluginDirectory, metadata.pluginId),
                nativeLibManager = NativeLibraryManager(),
                pluginId = metadata.pluginId
            )
            pluginContexts[metadata.pluginId] = pluginContext
            
            // 7. Call onLoad() with exception handling
            val loadSuccess = PluginExceptionHandler.safePluginBooleanCall(
                metadata.pluginId,
                "onLoad"
            ) {
                pluginInstance.onLoad(pluginContext)
            }
            
            if (!loadSuccess) {
                // Cleanup on failure
                pluginContexts.remove(metadata.pluginId)
                dexOutputDir.deleteRecursively()
                return@withContext Result.failure(Exception("Plugin.onLoad() returned false"))
            }
            
            // 8. Store plugin info
            val pluginInfo = PluginInfo(
                pluginId = metadata.pluginId,
                metadata = metadata,
                instance = pluginInstance,
                classLoader = classLoader,
                state = PluginState.LOADED,
                loadedAt = System.currentTimeMillis()
            )
            
            loadedPlugins[metadata.pluginId] = pluginInfo
            classLoaders[metadata.pluginId] = classLoader
            
            Timber.i("Plugin loaded: ${metadata.pluginName} v${metadata.version}")
            Result.success(pluginInfo)
            
        } catch (e: Exception) {
            Timber.e(e, "Failed to load plugin internally: ${pluginFile.name}")
            // Cleanup on error
            val metadata = try {
                extractPluginMetadata(pluginFile)
            } catch (ex: Exception) {
                null
            }
            metadata?.let {
                pluginContexts.remove(it.pluginId)
                File(context.codeCacheDir, "plugins/${it.pluginId}").deleteRecursively()
            }
            Result.failure(e)
        }
    }
    
    /**
     * Enables a plugin
     */
    suspend fun enablePlugin(pluginId: String): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val pluginInfo = loadedPlugins[pluginId]
                ?: return@withContext Result.failure(Exception("Plugin not found: $pluginId"))
            
            // Timeout protection with exception handling
            val enableSuccess = withTimeoutOrNull(PLUGIN_ENABLE_TIMEOUT_MS) {
                PluginExceptionHandler.safePluginBooleanCall(
                    pluginId,
                    "onEnable"
                ) {
                    pluginInfo.instance.onEnable()
                }
            } ?: return@withContext Result.failure(
                Exception("Plugin enable timeout after ${PLUGIN_ENABLE_TIMEOUT_MS}ms")
            )
            
            if (!enableSuccess) {
                return@withContext Result.failure(Exception("Plugin.onEnable() returned false"))
            }
            
            // Update state
            loadedPlugins[pluginId] = pluginInfo.copy(state = PluginState.ENABLED)
            
            Timber.i("Plugin enabled: $pluginId")
            Result.success(Unit)
        } catch (e: Exception) {
            Timber.e(e, "Failed to enable plugin: $pluginId")
            Result.failure(e)
        }
    }
    
    /**
     * Disables a plugin (but doesn't unload it)
     */
    suspend fun disablePlugin(pluginId: String): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val pluginInfo = loadedPlugins[pluginId]
                ?: return@withContext Result.failure(Exception("Plugin not found: $pluginId"))
            
            // Timeout protection with exception handling
            val disableSuccess = withTimeoutOrNull(PLUGIN_DISABLE_TIMEOUT_MS) {
                PluginExceptionHandler.safePluginBooleanCall(
                    pluginId,
                    "onDisable"
                ) {
                    pluginInfo.instance.onDisable()
                }
            } ?: return@withContext Result.failure(
                Exception("Plugin disable timeout after ${PLUGIN_DISABLE_TIMEOUT_MS}ms")
            )
            
            if (!disableSuccess) {
                return@withContext Result.failure(Exception("Plugin.onDisable() returned false"))
            }
            
            // Update state
            loadedPlugins[pluginId] = pluginInfo.copy(state = PluginState.DISABLED)
            
            Timber.i("Plugin disabled: $pluginId")
            Result.success(Unit)
        } catch (e: Exception) {
            Timber.e(e, "Failed to disable plugin: $pluginId")
            Result.failure(e)
        }
    }
    
    /**
     * Unloads a plugin
     */
    suspend fun unloadPlugin(pluginId: String): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val pluginInfo = loadedPlugins[pluginId]
                ?: return@withContext Result.failure(Exception("Plugin not found: $pluginId"))
            
            // Disable first
            disablePlugin(pluginId).getOrNull()
            
            // Call onUnload() with timeout and exception handling
            withTimeoutOrNull(PLUGIN_UNLOAD_TIMEOUT_MS) {
                PluginExceptionHandler.safePluginBooleanCall(
                    pluginId,
                    "onUnload"
                ) {
                    pluginInfo.instance.onUnload()
                }
            } ?: Timber.w("Plugin unload timeout for $pluginId, forcing cleanup")
            
            // Cleanup context
            pluginContexts[pluginId]?.cleanup()
            pluginContexts.remove(pluginId)
            
            // Cleanup ClassLoader and DEX cache
            classLoaders.remove(pluginId)
            File(context.codeCacheDir, "plugins/$pluginId").deleteRecursively()
            loadedPlugins.remove(pluginId)
            
            Timber.i("Plugin unloaded: $pluginId")
            Result.success(Unit)
        } catch (e: Exception) {
            Timber.e(e, "Failed to unload plugin: $pluginId")
            Result.failure(e)
        }
    }
    
    /**
     * Returns all loaded plugins
     */
    fun getLoadedPlugins(): List<PluginInfo> =
        loadedPlugins.values.toList()
    
    /**
     * Returns all enabled plugins
     */
    fun getEnabledPlugins(): List<PluginInfo> =
        loadedPlugins.values.filter { it.state == PluginState.ENABLED }
    
    /**
     * Gets a specific plugin by ID
     */
    fun getPlugin(pluginId: String): PluginInfo? =
        loadedPlugins[pluginId]
    
    private suspend fun extractPluginMetadata(pluginFile: File): PluginMetadata = withContext(Dispatchers.Default) {
        // Read plugin-manifest.json from JAR/AAB
        JarFile(pluginFile).use { jar ->
            val manifestEntry = jar.getEntry("plugin-manifest.json")
                ?: throw IllegalArgumentException("No plugin-manifest.json found")
            
            val jsonString = jar.getInputStream(manifestEntry).bufferedReader().readText()
            val json = JSONObject(jsonString)
            
            val requirements = json.optJSONObject("requirements") ?: JSONObject()
            
            PluginMetadata(
                pluginId = json.getString("pluginId"),
                pluginName = json.getString("pluginName"),
                version = json.getString("version"),
                author = json.optString("author", "Unknown"),
                minApiLevel = requirements.optInt("minApiLevel", 33),
                maxApiLevel = requirements.optInt("maxApiLevel", 36),
                minAppVersion = requirements.optString("minAppVersion", "1.0.0"),
                nativeLibraries = json.optJSONArray("nativeLibraries")?.let {
                    (0 until it.length()).map { i -> it.getString(i) }
                } ?: emptyList(),
                fragmentClassName = json.getString("fragmentClassName"),
                description = json.optString("description", ""),
                permissions = json.optJSONArray("permissions")?.let {
                    (0 until it.length()).map { i -> it.getString(i) }
                } ?: emptyList(),
                category = PluginCategory.valueOf(json.optString("category", "UTILITY")),
                dependencies = json.optJSONArray("dependencies")?.let {
                    (0 until it.length()).map { i -> it.getString(i) }
                } ?: emptyList()
            )
        }
    }
    
    private fun validatePlugin(metadata: PluginMetadata) {
        // Validate that app version is compatible
        val currentAppVersion = try {
            context.packageManager
                .getPackageInfo(context.packageName, 0).versionName ?: "1.0.0"
        } catch (e: Exception) {
            "1.0.0"
        }
        
        if (metadata.minAppVersion > currentAppVersion) {
            throw IllegalArgumentException(
                "Plugin requires app version ${metadata.minAppVersion}, " +
                "but current is $currentAppVersion"
            )
        }
        
        // Validate that fragmentClassName is not null
        if (metadata.fragmentClassName == null) {
            throw IllegalArgumentException("fragmentClassName is required")
        }
        
        // Validate API level
        val currentApiLevel = android.os.Build.VERSION.SDK_INT
        if (currentApiLevel < metadata.minApiLevel || currentApiLevel > metadata.maxApiLevel) {
            throw IllegalArgumentException(
                "Plugin requires API level ${metadata.minApiLevel}-${metadata.maxApiLevel}, " +
                "but current is $currentApiLevel"
            )
        }
    }
    
    fun shutdown() {
        scope.cancel()
        
        // Cleanup all plugin contexts
        pluginContexts.values.forEach { it.cleanup() }
        pluginContexts.clear()
        
        // Clear ClassLoaders
        classLoaders.clear()
        
        // Clear loaded plugins
        loadedPlugins.clear()
        
        Timber.i("PluginManager shutdown complete")
    }
}
